---
title: "Transfer Entrop Flow Analysis"
author: "Mariel Jones"
date: "2024-08-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
fig_save = "./Figures/"
load_path = "./mef-data/"
```

```{r}
library(astsa)
library(dplyr)
library(xts)
library(lubridate)
library(RTransferEntropy)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(forecastML)
library(cowplot)
library(reshape2)
library(zoo)
library(infotheo)
library(stringr)
library(latex2exp)
library(Hmisc)
library(plotly)
library(multcompView)
```

# Data Import

Including: 10 minute soil moisture, seasonal soil moisture, precipitation, streamflow, bog well WTE, temperature, and snow depth from GR

```{r}
#Import Soil Moisture and PDSI data
## 10 minute soil moisture
smURL  <- "https://pasta.lternet.edu/package/data/eml/edi/989/3/e25d4f15276a3158af412758502a59b0" 
smInfile <- tempfile()
try(download.file(smURL,smInfile,method="curl"))
if (is.na(file.size(smInfile))) download.file(smURL,smInfile,method="auto")

sm <-read.csv(smInfile, header=F, skip=1, sep=",", 
              col.names=c("TIMESTAMP", "S2S_UP_SH", "S2S_UP_DP", "S2S_MI_SH", 
                          "S2S_MI_DP", "S2S_LO_SH", "S2S_LO_DP", "S2N_UP_SH",     
                          "S2N_UP_DP", "S2N_MI_SH", "S2N_MI_DP", "S2N_LO_SH",     
                          "S2N_LO_DP"), check.names=TRUE)
               
unlink(smInfile)
tmp2TIMESTAMP<-as.POSIXct(sm$TIMESTAMP,format="%Y-%m-%d %H:%M:%S")
# Keep the new dates only if they all converted correctly
if(nrow(sm[sm$TIMESTAMP != "",]) == length(tmp2TIMESTAMP[!is.na(tmp2TIMESTAMP)])){sm$TIMESTAMP <- tmp2TIMESTAMP } else {print("Date conversion failed for sm$TIMESTAMP. Please inspect the data and do the date conversion yourself.")} 
#Aggregate to daily
sm$day <- floor_date(sm$TIMESTAMP, "day")
sm_daily = data.frame(sm) %>%
  group_by(day) %>%
  summarise_all(mean) %>%
  select(-TIMESTAMP)


#Seasonal Soil Moisture (previously processed)
seasm <-read.csv('./mef-data/seasonal/seasonal-soilM-grouped-untransformed.csv', header=T, sep=",")
         
# Precipitation
precipURL  <- "https://pasta.lternet.edu/package/data/eml/edi/563/6/f3a58ff544a4ddd3475d265da61bf40e" 
precipInfile <- tempfile()
try(download.file(precipURL,precipInfile,method="curl"))
if (is.na(file.size(precipInfile))) download.file(precipURL,precipInfile,method="auto")

precip <-read.csv(precipInfile , header=F, skip=1, sep = ",", 
               col.names=c("DATE", "NADP_PCP", "South_PCP", "North_PCP",     
                    "NADP_Flag", "South_Flag", "North_Flag") ,check.names=TRUE)
unlink(precipInfile)
tmp3DATE<-as.POSIXct(precip$DATE,format="%Y-%m-%d")
# Keep the new dates only if they all converted correctly
if(nrow(precip[precip$DATE != "",]) == length(tmp3DATE[!is.na(tmp3DATE)])){precip$DATE <- tmp3DATE } else {print("Date conversion failed for precip$TIMESTAMP. Please inspect the data and do the date conversion yourself.")}                                 
if (class(precip$South_PCP)=="factor") precip$South_PCP <-as.numeric(levels(precip$South_PCP))[as.integer(precip$South_PCP) ]               
if (class(precip$South_PCP)=="character") precip$South_PCP <-as.numeric(precip$South_PCP)
if (class(precip$South_Flag)!="factor") precip$South_Flag<- as.factor(precip$South_Flag)
                
# Convert Missing Values to NA for non-dates
precip$South_PCP <- ifelse((trimws(as.character(precip$South_PCP))==trimws("NA")),NA,precip$South_PCP)         

# Streamflow
streamURL  <- "https://pasta.lternet.edu/package/data/eml/edi/573/1/2aca4b900546e80ed7dd409ff1ad9787" 
streamInfile <- tempfile()
try(download.file(streamURL,streamInfile,method="curl"))
if (is.na(file.size(streamInfile))) download.file(streamURL,streamInfile,method="auto")

stream <-read.csv(streamInfile, header=F, skip=1, sep=",",
                  col.names=c("Peatland", "DateTime", "Stage.ft", "Q.cfs", "q.mmh", "q.interval"),
                  check.names=TRUE)
               
unlink(streamInfile)
if (class(stream$Peatland)!="factor") stream$Peatland<- as.factor(stream$Peatland)                       
tmp1DateTime<-as.POSIXct(stream$DateTime,format="%Y-%m-%d %H:%M:%S")
# Keep the new dates only if they all converted correctly
if(nrow(stream[stream$DateTime != "",]) == length(tmp1DateTime[!is.na(tmp1DateTime)])){stream$DateTime <- tmp1DateTime } else {print("Date conversion failed for stream$DateTime. Please inspect the data and do the date conversion yourself.")} 


# Bog well WTE
bogURL  <- "https://pasta.lternet.edu/package/data/eml/edi/562/3/671f15337a677da71852de506a8d9b05" 
bogInfile <- tempfile()
try(download.file(bogURL,bogInfile,method="curl"))
if (is.na(file.size(bogInfile))) download.file(bogURL,bogInfile,method="auto")

bog <-read.csv(bogInfile, header=F,skip=1, sep=",",
               col.names=c("PEATLAND", "DATE", "WTE", "FLAG"), check.names=TRUE)
               
unlink(bogInfile)
if (class(bog$PEATLAND)!="factor") bog$PEATLAND<- as.factor(bog$PEATLAND)                                   
tmp1DATE<-as.Date(bog$DATE,format="%Y-%m-%d")
# Keep the new dates only if they all converted correctly
if(nrow(bog[bog$DATE != "",]) == length(tmp1DATE[!is.na(tmp1DATE)])){bog$DATE <- tmp1DATE } else {print("Date conversion failed for bog$DATE. Please inspect the data and do the date conversion yourself.")}
if (class(bog$WTE)=="factor") bog$WTE <-as.numeric(levels(bog$WTE))[as.integer(bog$WTE) ]               
if (class(bog$WTE)=="character") bog$WTE <-as.numeric(bog$WTE)
if (class(bog$FLAG)!="factor") bog$FLAG<- as.factor(bog$FLAG)
                
# Convert Missing Values to NA for non-dates
bog$WTE <- ifelse((trimws(as.character(bog$WTE))==trimws("NA")),NA,bog$WTE)  

# Select just the S2 watershed
bog = bog %>%
  filter(PEATLAND == 'S2')

# import temperature data
tempURL  <- "https://pasta.lternet.edu/package/data/eml/edi/583/4/982d194dd32adb4419b14e936056c26c" 
tempInfile <- tempfile()
try(download.file(tempURL,tempInfile,method="curl"))
if (is.na(file.size(tempInfile))) download.file(tempURL,tempInfile,method="auto")

temp <-read.csv(tempInfile, header=F, skip=1, sep=",",
                col.names=c("Date", "STATION", "MAXC",  "MINC",  "FLAG"), check.names=TRUE)
               
unlink(tempInfile)
tmp1Date<-as.Date(temp$Date,format="%Y-%m-%d")  

head(temp)


#Snow depths
snow = read.csv('./mef-data/GR_ForestryLab_snow_daily.csv', 
                na.strings = c('M', 'T'))
snow$Date<-as.POSIXct(snow$Date,format="%Y-%m-%d")

```

## Snow Year Aggregation

Summarized the amount of snow that fell between October 1st and September 30th of the following year and allocates a 'high snow' and 'low snow' depending on if the total snowfall input is above or below the 70 year mean. 

```{r}
#Aggregate to snow year and sum snow inputs
snowAnnual = snow %>%
  mutate(snowYear = ifelse(month(Date) < 10, year(Date), year(Date) + 1)) %>%
  filter(snowYear > 1948) %>%
  group_by(snowYear) %>%
  summarise(totSnow = sum(Snow..inches., na.rm=TRUE))

snowAnnual = snowAnnual %>%
  mutate(typeS = ifelse(totSnow > mean(snowAnnual$totSnow), 'High', 'Low')) %>%
  mutate(year = snowYear) 

head(snowAnnual)
```

Finds the first day of the calendar year in the spring (aka water year in the spring) where snow is persistent on the ground and the last day of the water year where snow is persistent on the year and divides them into high and low snow years so that the 'snow season' can be specified based on a dynamic day where snow disapears, not a fixed date. 

```{r}
#Find first and last non-zero snow and streamflow values
snow_bounds = snow %>%
  mutate(year = year(Date)) %>%
  group_by(year) %>%
  summarise(firstNZ = yday(Date)[which((Snow.Depth..inches. != 0) & !is.na(Snow.Depth..inches.))[1]],
            lastNZ = yday(Date)[tail(which((Snow.Depth..inches. != 0) & (month(Date) < 10) & !is.na(Snow.Depth..inches.)))[5]]) 

snow_bounds_high = snow_bounds %>%
  filter(year %in% snowAnnual$snowYear[snowAnnual$typeS == 'High'])
snow_bounds_low = snow_bounds %>%
  filter(year %in% snowAnnual$snowYear[snowAnnual$typeS == 'Low'])
snow_bounds = rbind(snow_bounds_high, snow_bounds_low)

#stream_bounds = stream %>%
#  mutate(year = year(DateTime)) %>%
#  group_by(year) %>%
  #A threshold is set to eliminate the teeny tiny flows that continue dripping into January
#  summarise(firstNZ = yday(DateTime)[which((q.interval > 0.01) & !is.na(q.interval))[1]],
#            lastNZ = yday(DateTime)[tail(which((q.interval > 0.01) & !is.na(q.interval)))[5]]) 

#stream_bounds_high = stream_bounds %>%
#  filter(year %in% snowAnnual$snowYear[snowAnnual$type == 'High'])
#stream_bounds_low = stream_bounds %>%
#  filter(year %in% snowAnnual$snowYear[snowAnnual$type == 'Low'])
```

#Winter Temperature Aggregation

Similar to the snow dynamics, this allocates the seasonality based on the dynamic snow dates listed above and then takes the mean temperature over the designated 'snow' season. 

```{r}
#Divide seasonal temperatures based on the values in 'snow_bounds'
temp_seasons = temp %>%
  filter(STATION == 'South') %>%
  mutate(MEANC = (MAXC + MINC)/2) %>%
  mutate(year = year(Date)) %>%
  merge(snow_bounds, by = 'year') %>%
  mutate(snowYear = ifelse(month(Date) < 10, year(Date), year(Date) + 1)) %>%
  filter(snowYear > 1948) %>%
  mutate(season = ifelse(yday(Date) > lastNZ & yday(Date) < 183, 'Melt', ifelse(yday(Date) > 182 & yday(Date) < 275, 'Growing', 'Snow'))) %>%
  group_by(season, snowYear) %>%
  summarise(MEANC = mean(MEANC, na.rm = TRUE)) %>%
  rename('year' = 'snowYear')

#Find average snow temperatures
winterTemp = temp_seasons %>%
  filter(season == 'Snow') %>%
  mutate(typeT_snow = ifelse(MEANC > mean(MEANC), 'High', 'Low'))

#Find average growing temperatures 
growingTemp = temp_seasons %>%
  filter(season == 'Growing') %>%
  mutate(typeT_growing = ifelse(MEANC > mean(MEANC), 'High', 'Low'))

#Find average melt temperatures 
meltTemp = temp_seasons %>%
  filter(season == 'Melt') %>%
  mutate(typeT_melt = ifelse(MEANC > mean(MEANC), 'High', 'Low'))
```

```{r}
#Repeat for precipitation
#Divide seasonal precipitation based on the values in 'snow_bounds'
precip_seasons = precip %>%
  mutate(year = year(DATE)) %>%
  merge(snow_bounds, by = 'year') %>%
  mutate(snowYear = ifelse(month(DATE) < 10, year(DATE), year(DATE) + 1)) %>%
  filter(snowYear > 1948) %>%
  mutate(season = ifelse(yday(DATE) > lastNZ & yday(DATE) < 183, 'Melt', ifelse(yday(DATE) > 182 & yday(DATE) < 275, 'Growing', 'Snow'))) %>%
  group_by(season, snowYear) %>%
  summarise(totP = sum(South_PCP, na.rm = TRUE)) %>%
  rename('year' = 'snowYear')

#Find average snow temperatures
winterPrecip = precip_seasons %>%
  filter(season == 'Snow') %>%
  mutate(typeP_snow = ifelse(totP > mean(totP), 'High', 'Low'))

#Find average growing temperatures 
growingPrecip = precip_seasons %>%
  filter(season == 'Growing') %>%
  mutate(typeP_growing = ifelse(totP > mean(totP), 'High', 'Low'))

#Find average melt temperatures 
meltPrecip = precip_seasons %>%
  filter(season == 'Melt') %>%
  mutate(typeP_melt = ifelse(totP > mean(totP), 'High', 'Low'))

#Total annual precipitation
annualPrecip = precip_seasons %>%
  group_by(year) %>%
  summarise(totP = sum(totP)) %>%
  mutate(typeP = ifelse(totP > mean(totP), 'High', 'Low'))
  
```

Aggreagate everything to a seasonal basis and merge into one dataframe.

```{r}
#Aggregate to seasonal 
# 92 for April 1st
#105 for April 15th
precip_seasonal = data.frame(precip) %>%
  mutate(year = year(DATE)) %>%
  mutate(snowYear = ifelse(month(DATE) < 10, year(DATE), year(DATE) + 1)) %>%
  merge(snow_bounds, by = 'year') %>%
  mutate(season = ifelse(yday(DATE) > lastNZ & yday(DATE) < 183, 'Melt', ifelse(yday(DATE) > 182 & yday(DATE) < 275, 'Growing', 'Snow'))) %>%
  group_by(season, snowYear) %>%
  summarise(South_PCP = sum(South_PCP))%>%
  rename('year' = 'snowYear')

stream_seasonal = data.frame(stream) %>%
  mutate(year = year(DateTime)) %>%
  mutate(snowYear = ifelse(month(DateTime) < 10, year(DateTime), year(DateTime) + 1)) %>%
  merge(snow_bounds, by = 'year') %>%
  mutate(season = ifelse(yday(DateTime) > lastNZ & yday(DateTime) < 183, 'Melt', ifelse(yday(DateTime) > 182 & yday(DateTime) < 275, 'Growing', 'Snow'))) %>%
  group_by(season, snowYear) %>%
  summarise(qInterval = mean(q.interval, na.rm = TRUE)/10) %>%
  rename('year' = 'snowYear')

bog_seasonal = data.frame(bog) %>%
  mutate(year = year(DATE)) %>%
  mutate(snowYear = ifelse(month(DATE) < 10, year(DATE), year(DATE) + 1)) %>%
  merge(snow_bounds, by = 'year') %>%
  mutate(season = ifelse(yday(DATE) > lastNZ & yday(DATE) < 183, 'Melt', ifelse(yday(DATE) > 182 & yday(DATE) < 275, 'Growing', 'Snow'))) %>%
  group_by(season, snowYear) %>%
  summarise(WTE = mean(WTE)) %>%
  rename('year' = 'snowYear')

snow_seasonal = data.frame(snow) %>%
  mutate(year = year(Date)) %>%
  mutate(snowYear = ifelse(month(Date) < 10, year(Date), year(Date) + 1)) %>%
  merge(snow_bounds, by = 'year') %>%
  mutate(season = ifelse(yday(Date) > lastNZ & yday(Date) < 183, 'Melt', ifelse(yday(Date) > 182 & yday(Date) < 275, 'Growing', 'Snow'))) %>%
  group_by(season, snowYear) %>%
  summarise(Snow_in = sum(Snow..inches., na.rm = TRUE)) %>%
  rename('year' = 'snowYear')

seasm_melt = seasm %>%
  select(c(YEAR, LOCATION, season, d.15, d.76, d.137)) %>%
  pivot_wider(names_from = LOCATION, values_from = c(d.15, d.76, d.137)) %>%
  rename('year' = 'YEAR')

#merge into dataset
dat = merge(x = precip_seasonal, stream_seasonal, by = c('season', 'year'), how = 'inner')
dat = merge(dat, bog_seasonal, by = c('season', 'year'), how = 'inner')
dat = merge(dat, snow_seasonal, by = c('season', 'year'), how = 'inner')
dat = merge(dat, temp_seasons, by = c('season', 'year'), how = 'inner')
dat = merge(dat, seasm_melt, by = c('season', 'year'), how = 'inner') %>% 
  arrange(year, season) 
```

```{r}
dat
```

## Initial Data Exploration

```{r}
#Bunch o' boxplots
par(mfrow = c(2, 5), 
        mar = c(4, 2, 4, 2))

for(col in colnames(dat)[3:12]){
  boxplot(dat[, col] ~ dat$season, xlab = ' ')
  title(col)
}
```

## Seasonal Mutual Information

Transfer entropy is now calculated as lagged mutual information by taking a variable from a single season and comparing it to another variable of another season at a specified lag to determine the amount of 'information' or correlation that a variable from the previous season (or two seasons ago) may have on a variable in the current season. For simplicity the 'sink' variable is defined as streamflow and all other variables are considered to be 'source' variables at lags of 1-2 seasons. 

```{r}
data_seasonal = dat %>%
  drop_na() %>%
  relocate(c("qInterval", "year", "season")) %>%
  #Order seasons so they show up in "Snow", "Melt", "Streamflow" order
  mutate(season = factor(season, levels = c('Growing', 'Melt', 'Snow')))  %>% 
  group_by(year) %>% 
  filter(all(c('Snow', 'Melt', 'Growing') %in% season))

summary(data_seasonal)
```

```{r}
#Sort into high and low snow year data frames (based on calendar year, not snow year)
#Snow only
highSnow_seasonal = data_seasonal %>%
  filter(year %in% snowAnnual$snowYear[snowAnnual$typeS == 'High'])

lowSnow_seasonal = data_seasonal %>%
  filter(year %in% snowAnnual$snowYear[snowAnnual$typeS == 'Low'])

#Temp only
highTemp_seasonal = data_seasonal %>%
  filter(year %in% winterTemp$year[winterTemp$typeT_snow == 'High'])

lowTemp_seasonal = data_seasonal %>%
  filter(year %in% winterTemp$year[winterTemp$type_snow == 'Low'])

#Both 
highShighT_seasonal = data_seasonal %>%
  filter((year %in% snowAnnual$snowYear[snowAnnual$typeS == 'High']) &
           (year %in% winterTemp$year[winterTemp$typeT_snow == 'High']))

lowShighT_seasonal = data_seasonal %>%
  filter((year %in% snowAnnual$snowYear[snowAnnual$typeS == 'Low']) &
           (year %in% winterTemp$year[winterTemp$typeT_snow == 'High']))

highSlowT_seasonal = data_seasonal %>%
  filter((year %in% snowAnnual$snowYear[snowAnnual$typeS == 'High']) &
           (year %in% winterTemp$year[winterTemp$typeT_snow == 'Low']))

lowSlowT_seasonal = data_seasonal %>%
  filter((year %in% snowAnnual$snowYear[snowAnnual$typeS == 'Low']) &
           (year %in% winterTemp$year[winterTemp$typeT_snow == 'Low']))

#Annual Snow and Annual Precip 
highShighP_seasonal = data_seasonal %>%
  filter((year %in% snowAnnual$snowYear[snowAnnual$typeS == 'High']) &
           (year %in% annualPrecip$year[annualPrecip$typeP == 'High']))

lowShighP_seasonal = data_seasonal %>%
  filter((year %in% snowAnnual$snowYear[snowAnnual$typeS == 'Low']) &
           (year %in% annualPrecip$year[annualPrecip$typeP == 'High']))

highSlowP_seasonal = data_seasonal %>%
  filter((year %in% snowAnnual$snowYear[snowAnnual$typeS == 'High']) &
           (year %in% annualPrecip$year[annualPrecip$typeP == 'Low']))

lowSlowP_seasonal = data_seasonal %>%
  filter((year %in% snowAnnual$snowYear[snowAnnual$typeS == 'Low']) &
           (year %in% annualPrecip$year[annualPrecip$typeP == 'Low']))

#Add general labels to data_seasonal
data_seasonal = data_seasonal %>%
  mutate(yearCat = ifelse(year %in% highShighP_seasonal$year, 'highShighP', 
           ifelse(year %in% lowShighP_seasonal$year, 'lowShighP', 
           ifelse(year %in% highSlowP_seasonal$year, 'highSlowP', 'lowSlowP')))) %>%
  mutate(season = factor(season, levels = c('Melt','Growing', 'Snow'),ordered = TRUE))

head(data_seasonal)
```


```{r}
## Shift time series
lagTS = function(x, y, l){
  #Shift
  shiftedX = lag(x, n = l)
  shiftedY = lag(y, n = 0)
  
  #Merge into data frame and clip to non-na
  dat = data.frame(shiftedX, shiftedY) %>%
    drop_na()
  
  return(dat)
}

#Seasonal calculation
calc_seasonalQ_contribution_Conditional = function(var, lag, data, subset = FALSE, listYears = NULL){
    t = c()
    
    #Sort
    data = data[order(data$year, data$season),]
    
    #Lag timeseries
    lagDat = lagTS(data[, var], data$qInterval, lag)
    
    if(lag > 0){
      #Lag autocorrelation
      lagY = lagTS(data$qInterval, data$qInterval, lag-1)
          
      #Attach monthly values
      lagDat = cbind(lagDat, season = data$season[0:(length(data$season)-lag)],
                     z = lagY$shiftedY[0:(length(lagY$shiftedY) - 1)], 
                     years = data$year[0:(length(data$year)-lag)])
    }
    else if(lag == 0){
      #lag autocorrelation
      lagY = lagTS(data$qInterval, data$qInterval, 1)
      
      #Attach monthly values
      lagDat = cbind(lagDat[2:length(lagDat$shiftedY),],
                     season = data$season[2:length(data$season)],
                     z = lagY$shiftedX, 
                     years = data$year[2:length(data$year)])
          
    }


    for(i in c('Snow', 'Melt', 'Growing')){
        #filter season
        lagDat_seasonal = lagDat %>% 
          filter(season == i)
        
        #filter years
        if(subset == TRUE){
          lagDat_seasonal = lagDat_seasonal %>%
            filter(years %in% listYears)
        }
        

        #calculate mutual information
        t = append(t, natstobits(condinformation(X = discretize(lagDat_seasonal[, var]),
                                          Y = discretize(lagDat_seasonal$shiftedY), 
                                          S = discretize(lagDat_seasonal$z))))
        
        #print(paste("Variable:", var, ", Lag:", lag, ", Season:", i, ", MI:", temp[length(temp)]))
    }
    
    return(t)
}

calc_seasonalQ_correlations = function(var, lag, data, subset = FALSE, listYears = NULL){
  t = c()
  
  #Sort
  data = data[order(data$year, data$season),]
    
  #print(paste0("Variable: ", var, " Lag: ", lag))
  #print("-----")
  #Lag timeseries
  lagDat = lagTS(data[, var], data$qInterval, lag)
  
  #Attach monthly values
  lagDat = cbind(lagDat, season = data$season[0:(length(data$season)-lag)], 
                 years = data$year[0:(length(data$year)-lag)])
    
  for(i in c('Snow', 'Melt', 'Growing')){
    #filter seasons
    lagDat_seasonal = lagDat %>% filter(season == i) 
    
    #filter years
    if(subset == TRUE){
        lagDat_seasonal = lagDat_seasonal %>%
          filter(years %in% listYears)
    }

    #correlation
    r = cor(x = lagDat_seasonal[,var], y = lagDat_seasonal$shiftedY)
    #print(paste0("Season: ", i, ", R2 = ", r))
    t = append(t, r)

  }
  
  return(t)
}
```


```{r}
#PLOTTING FUNCTIONS
vars = c("South_PCP", "WTE", "MEANC", "Snow_in", "d.15_S2E", "d.15_S2S", "d.76_S2E", "d.76_S2S", "d.137_S2E", "d.137_S2S")

buff = 0.2

plotMI_original = function(data){
  #Time series based plots
  #Transfer Entropy, i.e. Conditional Mutual Information
  for(lag in seq(0, 2)){
    seasonal_MI_data = data.frame(matrix(ncol = 0, nrow = 3))
    seasonal_R_data = data.frame(matrix(ncol = 0, nrow = 3))
    
    for(v in vars){
      seasonal_MI_data[v] = calc_seasonalQ_contribution_Conditional(v, lag, data)
      seasonal_R_data[v] = calc_seasonalQ_correlations(v, lag, data)
    }
    
    #Plot stacked time series (plus shifted data)
    x  = c("Snow", "Melt", "Growing")
    seasons = c(x[(lag+1:(length(x)-lag))], x[1:lag])
    seasonal_MI_data = seasonal_MI_data %>% 
       mutate(season_source = factor(x, levels = c("Snow", "Melt", "Growing"))) %>%
       mutate(season_target = factor(seasons, levels = c("Snow", "Melt", "Growing"))) %>%
       gather(variable, value, vars)
    
    #1 - streamflow, 2 - frost, 3 - melt
    monthlyplot = ggplot(data = seasonal_MI_data, aes(x = season_target, y = value, fill = variable)) +
      #Plot
      geom_col(position = 'dodge') +
      scale_fill_brewer(palette = "BrBG") + 
      ylim(0, 1) + 
      xlab(' ') + 
      ylab('Conditional Mutual Information') +
      theme(legend.position = 'bottom',
            panel.background = element_blank()) #+
      #scale_x_discrete(labels = c('Streamflow', 'Frost', 'Melt'), 
      #                 limits=c("1","2","3"))
  
    seasonal_R_data = seasonal_R_data %>% 
       mutate(season_source = factor(x, levels = c("Snow", "Melt", "Growing"))) %>%
       mutate(season_target = factor(seasons, levels = c("Snow", "Melt", "Growing"))) %>%
       gather(variable, value, vars)
    
    monthlyplot_corr = ggplot(data = seasonal_R_data, aes(x = season_target, y = value, col = variable)) +
      geom_line() +
      geom_point() + 
      scale_color_brewer(palette = "BrBG") + 
      ylim(-1, 1) + 
      xlab(' ') + 
      ylab('Pearson R') +
      ggtitle(paste0('Streamflow Contributions at lag ', lag)) +
      theme(legend.position = 'none',
            panel.background = element_blank()) #+
      #scale_x_discrete(labels = c('Streamflow', 'Frost', 'Melt'), 
      #                 limits=c("1","2","3"))
  
    fullplot = plot_grid(monthlyplot_corr, monthlyplot, 
              ncol = 1,
              axis = 'l',
              align = 'v',
              rel_heights = c(2,3))
  
    print(fullplot)
    
  }
}

plotMI_modified = function(data, title, years = NULL){
  
    #set factor levels
    data = data %>%
      mutate(season = factor(season, levels = c("Snow", "Melt", "Growing")))
      
    for(lag in seq(0, 2)){
      seasonal_MI_data = data.frame(matrix(ncol = 0, nrow = 3))
      seasonal_R_data = data.frame(matrix(ncol = 0, nrow = 3))
      
      for(v in vars){
        
        if(is.null(years)){
          seasonal_MI_data[v] = calc_seasonalQ_contribution_Conditional(v, lag, data)
          seasonal_R_data[v] = calc_seasonalQ_correlations(v, lag, data)
        }
        else{
          seasonal_MI_data[v] = calc_seasonalQ_contribution_Conditional(v, lag,
                                                                        data, subset = TRUE, listYears = years)
          seasonal_R_data[v] = calc_seasonalQ_correlations(v, lag,
                                                           data, subset = TRUE, listYears = years)
        }
        
      }
      
      #Plot stacked time series (plus shifted data)
      x  = c("Snow", "Melt", "Growing")
      if(lag > 0){
        seasons = c(x[(lag+1:(length(x)-lag))], x[1:lag])
      }
      else if(lag == 0){
        seasons = x
      }

      seasonal_MI_data = seasonal_MI_data %>% 
         mutate(season_source = factor(x, levels = c("Snow", "Melt", "Growing"))) %>%
         mutate(season_target = factor(seasons, levels = c("Snow", "Melt", "Growing"))) %>%
         gather(variable, value, vars)
      
      seasonal_R_data = seasonal_R_data %>% 
         mutate(season_source = factor(x, levels = c("Snow", "Melt", "Growing"))) %>%
         mutate(season_target = factor(seasons, levels = c("Snow", "Melt", "Growing"))) %>%
         gather(variable, value, vars)
      
      #Change value sign based on R2 value
      seasonal_MI_data = seasonal_MI_data %>%
        mutate(value = ifelse(seasonal_R_data$value < 0, -value, value))
      
      #1 - streamflow, 2 - frost, 3 - melt
      monthlyplot = ggplot(data = seasonal_MI_data, aes(x = season_target, y = value, fill = variable)) +
        #Plot
        geom_col(position = 'dodge') +
        scale_fill_brewer(palette = "BrBG") + 
        ylim(-1, 1) + 
        xlab(' ') + 
        ylab('Conditional Mutual Information') +
        theme(legend.position = 'bottom',
              panel.background = element_blank()) +
        ggtitle(paste0(title, ', Lag ', lag))
    
      print(monthlyplot)
      ggsave(paste0('./Figures/Quadrat Plots/', title, '_Lag', lag, '.pdf'))
  }
}

plotMI_variables = function(data){
  #Variable based plots
  #Transfer Entropy, i.e. Conditional Mutual Information
  for(v in vars){
    seasonal_MI_var_data = data.frame(matrix(ncol = 0, nrow = 3))
    seasonal_R_var_data = data.frame(matrix(ncol = 0, nrow = 3))
    
    for(lag in seq(0, 2)){
      temp = calc_seasonalQ_contribution_Conditional(v, lag, data)
      temp_corr = calc_seasonalQ_correlations(v, lag, data)
      #time shift the MI values
      seasonal_MI_var_data[lag] = c(temp[(length(temp)-lag+1):length(temp)], temp[1:(length(temp)-lag)])
      seasonal_R_var_data[lag] = c(temp_corr[(length(temp_corr)-lag+1):length(temp_corr)], temp_corr[1:(length(temp_corr)-lag)])
    }
    
    #Plot stacked time series (plus shifted data)
    x  = seq(1:3)
    seasonal_MI_var_data = seasonal_MI_var_data %>% 
      mutate(season = x) %>%
      melt(id.vars = c('season'))
    
    seasonalplot_stacked = ggplot(data = seasonal_MI_var_data, aes(x = season, y = value, fill = variable)) +
      geom_col(position = 'dodge') +
      scale_fill_brewer(palette = "PuBuGn") + 
      xlim(1,3) +
      ylim(0, 1) + 
      xlab(' ') + 
      ylab('Conditional Mutual Information') +
      theme(legend.position = 'bottom',
            panel.background = element_blank()) 
    
    seasonal_R_var_data = seasonal_R_var_data %>% 
      mutate(season = x) %>%
      melt(id.vars = c('season'))
    
    seasonalplot_corr = ggplot(data = seasonal_R_var_data, aes(x = season, y = value, col = variable)) +
      geom_line() +
      geom_point() + 
      scale_color_brewer(palette = "PuBuGn") + 
      xlim(1,3) +
      ylim(-1, 1) + 
      xlab(' ') + 
      ylab('Pearson R') +
      ggtitle(paste0('Lagged Streamflow Contributions from ', v)) +
      theme(legend.position = 'none',
            panel.background = element_blank()) #+
      #scale_x_discrete(labels = c('Streamflow', 'Frost', 'Melt'), 
      #                 limits=c("1","2","3")) 
    
    fullplot = plot_grid(seasonalplot_corr, seasonalplot_stacked, 
              ncol = 1,
              axis = 'l',
              align = 'v',
              rel_heights = c(2,3))
  
    print(fullplot)
      
  }
}
```

## Plots

Considering first all data together, not separated by annual climatological or hydrological conditions. 

```{r}
#All data
plotMI_modified(data_seasonal, "All Years")
```

Then, we could separate data by the high or low snow year designation and plot the same diagrams separated by snow regime. 

```{r}
## High Snow Years
plotMI_modified(data_seasonal, 'High Snow Years', unique(highSnow_seasonal$year))

## Low Snow Years
plotMI_modified(data_seasonal, 'Low Snow Years', unique(lowSnow_seasonal$year))
```

or, by winter temperature. 

```{r}
## High Temp Years
plotMI_modified(data_seasonal, 'High Temp Years', unique(highTemp_seasonal$year))

## Low Temp Years
plotMI_modified(data_seasonal, 'Low Temp Years', unique(lowTemp_seasonal$year))
```

Or even by both winter temperature and snow regime. 

```{r}
## High Temp, High Snow Years
# Not possible - Only 1 data pt

print("High Temp - Low Snow")
print("-----------------------------")
## High Temp, Low Snow
plotMI_modified(data_seasonal,'High Temp, Low Snow', unique(lowShighT_seasonal$year))


print("Low Temp - High Snow")
print("-----------------------------")
## Low Temp, High Snow
plotMI_modified(data_seasonal, 'Low Temp, High Snow', unique(highSlowT_seasonal$year))


print("Low Temp - Low Snow")
print("-----------------------------")
## Low Temp, Low Snow
plotMI_modified(data_seasonal, 'Low Temp, Low Snow', unique(lowSlowT_seasonal$year))
```

```{r}
#Version with snowfall and precipitation on annual basis

print("High Precip - High Snow")
print("-----------------------------")
## High Precip, High Snow Years
plotMI_modified(data_seasonal,'High Precip, High Snow', unique(highShighP_seasonal$year))

print("High Precip - Low Snow")
print("-----------------------------")
## High Precip, Low Snow
plotMI_modified(data_seasonal,'High Precip, Low Snow', unique(lowShighP_seasonal$year))


print("Low Precip - High Snow")
print("-----------------------------")
#Not enough data points
## Low Precip, High Snow
plotMI_modified(data_seasonal, 'Low Precip, High Snow', unique(highSlowP_seasonal$year))


print("Low Precip - Low Snow")
print("-----------------------------")
## Low Temp, Low Snow
plotMI_modified(data_seasonal, 'Low Precip, Low Snow', unique(lowSlowP_seasonal$year))
```

But, how do we determine which of these confouding climatological or hydrological variables are the most influential in determining time-lagged hydrological connectivity? There are a variety of options that all influence snow accumulation and melt and soil frost dynamics: Annual Precipitation, Snow Accumulation, Winter Temperature, Spring Temperature, Annual Temperature, Fall Precipitation, etc. If we think that this connectivity is driven predominantly by soil frost depth and timing, then we need to look at which of these variables end up with the most distict frost scenarios. 

```{r}
generate_label_df <- function(TUKEY, variable){
 
     # Extract labels and factor levels from Tukey post-hoc 
     Tukey.levels <- TUKEY[[variable]][,4]
     Tukey.labels <- data.frame(multcompLetters(Tukey.levels)['Letters'])
     
     #I need to put the labels in the same order as in the boxplot :
     Tukey.labels$treatment=rownames(Tukey.labels)
     Tukey.labels=Tukey.labels[order(Tukey.labels$treatment) , ]
     return(Tukey.labels)
}

plotQuadratVar = function(var, ylabel, tukey = TRUE){
  quadPlot = ggplot(data = data_seasonal, aes(x = data_seasonal$season, y = data_seasonal[[var]])) +
    geom_boxplot() + 
    facet_wrap(vars(yearCat)) +
    xlab('Season') +
    ylab(ylabel) + 
    theme_bw() + 
    theme(strip.text = element_text(face = "bold", hjust = 0),
    strip.background = element_blank())
    
  if(tukey){
      model = lm(unlist(data_seasonal[var]) ~ data_seasonal$season*data_seasonal$yearCat)
      ANOVA=aov(model)
      
      TUKEY <- TukeyHSD(x=ANOVA, conf.level=0.95, ordered = FALSE)
      
      #get labels
      letters = generate_label_df(TUKEY, "data_seasonal$season:data_seasonal$yearCat")
      names(letters)<-c('Letters','Treatment')
      #set locations
      yvalue<-aggregate(.~season*yearCat, data=data_seasonal, max) %>%
        mutate(Treatment = paste0(season, ":", yearCat))
      print(yvalue)
      final <- merge(letters,yvalue) #merge dataframes

      par(mfrow = c(1, 3), 
          mar = c(4, 4, 4, 4))
      plot(TUKEY, las = 1, col="brown")
      
      #add labels to plot
      quadPlot = quadPlot + 
        geom_text(data = final, aes(x = season, y = max(final[var]), label = Letters, 
                                    hjust = -0.5, vjust = 0.75)) 
  }
  
  ggsave(filename = paste0('./Figures/VariablePlots/', var, '.pdf'), quadPlot)
  print(quadPlot)

  
}
```

```{r}
#'qInterval', 'South_PCP', 'WTE', 'Snow_in', 'MEANC', 'd.15_S2E', 'd.15_S2S', 'd.76_S2E', 'd.76_S2S', 'd.137_S2E', 'd.137_S2S'

plotQuadratVar(var = 'd.137_S2S', ylab = 'Soil Moisture [cm3/cm3]')
```


# Frost Analysis by Hydrology and Climatology Variables

Import frost depth data from Marcell:

```{r}
#Upland Frost Depths
frostUplandURL  <- "https://pasta.lternet.edu/package/data/eml/edi/571/3/cf159d50f0e80a99b14830103eec9297" 
frostUplandInfile <- tempfile()
try(download.file(frostUplandURL, frostUplandInfile, method="curl"))
if (is.na(file.size(frostUplandInfile))) download.file(frostUplandURL, frostUplandInfile, method="auto")

frostUplandAll <-read.csv(frostUplandInfile, header=F, skip=1, sep=",",
                       col.names=c("Watershed", "SnowcourseID", "Date", "Point", "FrostDEPTH"),
                       check.names=TRUE)
               
unlink(frostUplandInfile)
		    
# attempting to convert dt2$Date dateTime string to R date structure (date or POSIXct)   
tmp2Date<-as.Date(frostUplandAll$Date, format = "%Y-%m-%d")
# Keep the new dates only if they all converted correctly
if(nrow(frostUplandAll[frostUplandAll$Date != "",]) == length(tmp2Date[!is.na(tmp2Date)])){frostUplandAll$Date <- tmp2Date } else {print("Date conversion failed for dt2$Date. Please inspect the data and do the date conversion yourself.")}   

#Filter only S2
frostUpland = frostUplandAll %>% 
  filter(frostUplandAll$SnowcourseID %in% c('S21', 'S22', 'S23'))
  

#Bog Frost Depths
frostBogURL  <- "https://pasta.lternet.edu/package/data/eml/edi/572/1/fbbdd3f237bbde445450d897172ba556" 
frostBogInfile <- tempfile()
try(download.file(frostBogURL, frostBogInfile, method="curl"))
if (is.na(file.size(frostBogInfile))) download.file(frostBogURL, frostBogInfile,method="auto")

frostBog <-read.csv(frostBogInfile, header=F, skip=1, sep=",", 
                    col.names=c("peatland", "year", "frostDate", "depthToFrost", "frostThickness", "frostPercent"), 
                    check.names=TRUE)
               
unlink(frostBogInfile)
		    
# Fix any interval or ratio columns mistakenly read in as nominal and nominal columns read as numeric or dates read as strings
if (class(frostBog$peatland)!="factor") frostBog$peatland<- as.factor(frostBog$peatland)                                   
# attempting to convert dt1$frostDate dateTime string to R date structure (date or POSIXct)                                
tmp1frostDate<-as.Date(frostBog$frostDate, format="%Y-%m-%d")
# Keep the new dates only if they all converted correctly
if(nrow(frostBog[frostBog$frostDate != "",]) == length(tmp1frostDate[!is.na(tmp1frostDate)])){frostBog$frostDate <- tmp1frostDate } else {print("Date conversion failed for dt1$frostDate. Please inspect the data and do the date conversion yourself.")}  

#Filter only S2
frostBog = frostBog %>%
  filter(peatland == 'S2')
```

```{r}
#Manipulate to add snow years and the precip, snow allocations 
#Add years
frostUpland = frostUpland %>%
  mutate(year = year(Date)) %>%
  merge(snowAnnual[c('year', 'typeS')], on = 'year') %>% #Annual Snow Accumulation
  merge(annualPrecip[c('year', 'typeP')], on = 'year') %>% #Annual Precip 
  merge(winterPrecip[c('year', 'typeP_snow')], on = 'year') %>% #Snow Season Precipitation
  merge(meltPrecip[c('year', 'typeP_melt')], on = 'year') %>% #Melt Season Precipitation
  merge(growingPrecip[c('year', 'typeP_growing')], on = 'year') %>% #Growing Season Precipitation
  merge(winterTemp[c('year', 'typeT_snow')], on = 'year') %>% #Snow Season Temperature
  merge(meltTemp[c('year', 'typeT_melt')], on = 'year') %>% #Melt Season Temperature
  merge(growingTemp[c('year', 'typeT_growing')], on = 'year') #Growing Season Temperature

frostUpland
```

```{r}
plotFrost = function(x, y, xlab, ylab){
  par(mfrow = c(2, 2), 
          mar = c(4, 4, 4, 4))
  
  #High X, High Y
  dat1 = frostUpland %>%
    filter((year %in% frostUpland$year[frostUpland[,x] == 'High']) &
             (year %in% frostUpland$year[frostUpland[,y] == 'High']))
  if(nrow(dat1) > 0){
    boxplot(dat1$FrostDEPTH ~ dat1$SnowcourseID, ylab = 'Frost Depth (cm)',
          ylim = c(0, max(frostUpland$FrostDEPTH)), 
          xlab = '')
    title(paste0('High ', xlab, ', High ', ylab))
  }
  
  #High X, Low Y
  dat2 = frostUpland %>%
    filter((year %in% frostUpland$year[frostUpland[,x] == 'High']) &
             (year %in% frostUpland$year[frostUpland[,y] == 'Low']))
  if(nrow(dat2) > 0){
    boxplot(dat2$FrostDEPTH ~ dat2$SnowcourseID, ylab = 'Frost Depth (cm)', 
          ylim = c(0, max(frostUpland$FrostDEPTH)), 
          xlab = '')
    title(paste0('High ', xlab, ', Low ', ylab))
  }
  
  #Low X, High Y
  dat3 = frostUpland %>%
    filter((year %in% frostUpland$year[frostUpland[,x] == 'Low']) &
             (year %in% frostUpland$year[frostUpland[,y] == 'High']))
  if(nrow(dat3) > 0){
    boxplot(dat3$FrostDEPTH ~ dat3$SnowcourseID, ylab = 'Frost Depth (cm)', 
          ylim = c(0, max(frostUpland$FrostDEPTH)), 
          xlab = '')
    title(paste0('Low ', xlab, ', High ', ylab))
  }
  
  #Low X, Low Y
  dat4 = frostUpland %>%
    filter((year %in% frostUpland$year[frostUpland[,x] == 'Low']) &
             (year %in% frostUpland$year[frostUpland[,y] == 'Low']))
  if(nrow(dat4) > 0){
    boxplot(dat4$FrostDEPTH ~ dat4$SnowcourseID, ylab = 'Frost Depth (cm)', 
          ylim = c(0, max(frostUpland$FrostDEPTH)), 
          xlab = '')
    title(paste0('Low ', xlab, ', Low ', ylab))
  }
}

```

```{r}
x = 'typeP'
y = 'typeS'
xlab = 'Annual Precip'
ylab = 'Annual Snowfall'
plotFrost(x, y, xlab, ylab)
```











